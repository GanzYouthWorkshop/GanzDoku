II. A C# nyelv alaptípusai
Egy programozási nyelvben az egyik legfontosabb tulajdonság az, hogy programkészítés során hogyan és milyen típusú adatokat használhatunk. Meg kell jegyezni, hogy van néhány olyan programozási nyelv is (pl. PhP), ahol ez a terület nem igazán fontos, típusok gyakorlatilag nincsenek, adatot szükség szerinti típusban a programozó rendelkezésére bocsát. A C# szigorúan típusos nyelv, ebben a nyelvben csak ennek figyelembe-vételével használhatunk saját változókat.

II.1. Változók definiálása
A nyelvben a változók definiálásának alakja:
típus változónév;
Azonos típusú változókat egymástól vesszõvel elválasztva definiálhatunk. A típusok ismerete nélkül nézzünk néhány példát változók definiálására. Példa:
char ch; // ch változó karakter típusú
int egy, tizenegy; // az egy és tizenegy egész típusú
Változók lehetnek külsõk, azaz függvényen kívüliek, vagy belsõk, azaz függvényen belüliek. A függvényen kívüli változók is természetesen csak osztá-lyon belüliek lehetnek. Gyakran hívják ezeket a változókat adatmezõknek is. Belsõ változók, az adott blokkon (függvényen) belüli lokális változók lehet-nek dinamikus vagy statikus élettartamúak. Módosító jelzõ nélküli definiálás esetén dinamikusnak vagy automatikusnak nevezzük, s ezek élettartama a blokk-ban való tartózkodás idejére korlátozódik. Ha a blokk végrehajtása befejezõdött, a dinamikus változók megszûnnek. Statikus élettartamú belsõ változót a static szó használatával (ahogy külsõváltozó esetén igen) nem definiálhatunk. Láttuk, a függvények lehetnek stati-kusak (lásd Main függvény), melyekre ugyanaz igaz, mint az osztályváltozókra, ezen függvények élettartama is a programéval egyezik meg, más szóval ezen függvények a program indulásakor jönnek létre. II. A C# nyelv alaptípusaiA változókat két kategóriába sorolhatjuk, az osztálytípusú változók referen-cia típusúak, melyek mindig a dinamikus memóriában helyezkednek el (az irodalomban ezt gyakran heap-nek nevezik), míg minden más nem osztály-típusú, az úgynevezett értéktípusú (value type) változó. Az értéktípusú vál-tozókat szokták stack változóknak is nevezni. Az értéktípusú változók kezdõértékét, az inicializálás hiányában, 0, false, null értékre állítja be a fordító. A változók definiálásakor rögtön elvégezhetõ azok direkt inicializálása is. II.2. Állandók definiálása Állandók definiálását a típusnév elé írt const típusmódosító szócska segítsé-gével tehetjük meg. A definíció alakja: const típus név = érték; Példa: const float g=9.81; // valós konstans g=2.3; // !!! HIBA ... const int min=0; // egész konstans II.3. Változók inicializálása Változók kezdõ értékadása, inicializálása azok definiálásakor is elvégezhetõa következõ formában: típus változó = érték; Példa: char s='a'; int []a={1,2,3}; char[] b="Egy"; A változók, konstansok és függvények használatára nézzük a következõpéldát. II. A C# nyelv alaptípusai Példa: // A valtozo.cs fájl tartalma: using System; // A kiíráshoz szükséges deklarációt tartalmazza. class változó { static int alma=5; //alma változó definíciója //és inicializálása static float r=5.6F //statikus valós típusú változó //valós konstanst zárhat az //F (float) betû const float pi=3.1415; //konstans definíció static void Main() { Console.WriteLine( "Teszt"); //eredmény Test Console.WriteLine( alma ); //eredmény 5 int alma=6; //helyi változó Console.WriteLine( alma ) ; //eredmény 6 Console.WriteLine( változó.alma ); //a külsõ takart (5) //változóra hivatkozás Console.WriteLine( terület(r)); //a terület függvény // meghívása } static float terület(float sugár) // függvénydefiníció { return(pi*sugár*sugár); } } Bár még nem definiáltunk függvényeket, így talán korainak tûnhet ez a példa, de inkább felhívnám még egyszer a figyelmet az ékezetes karakterek használatára. A késõbbi mintafeladatokban, ha elõfordul ékezet nélküli változó, függvénydefiníció, akkor az csak a korábbi környezetek „rossz utóhatásának” köszönhetõ. Egy osztályon belül a függvények definiálási sorrendje nem lényeges. Sok környezetben furcsa lehet amit a fenti példában látunk, hogy elõbb használjuk, és csak ezután definiáljuk a függvényünket. (terület függvény) II.4. Elemi típusok char – karakter típus (2 byte hosszú) II. A C# nyelv alaptípusaiA karakter típus 16 bites karakterábrázolást (unikód) használ. Általában igaz, hogy minden alaptípus mérete rögzített. A karakter típusú változó értékét aposztróf (') jelek között tudjuk megadni. Példa: char c; c='a'; A backslash (\) karakter speciális jelentéssel bír. Az utána következõ karak-ter(eke)t, mint egy escape szekvenciát dolgozza föl a fordító. Az így használható escape szekvenciák a következõk: \a - a 7-es kódú csipogás \b - backspace, elõzõ karakter törlése \f - formfeed, soremelés karakter \r - kocsi vissza karakter \n - új sor karakter (soremelés+kocsi vissza) Az új sor karakter hatása azonos a formfeed és a kocsi vissza karakterek hatásával. \t - tabulátor karakter \v - függõleges tabulátor \\ - backslash karakter \' - aposztróf \" - idézõjel \? - kérdõjel \uxxyy xx és yy unikódú karakter string – karaktersorozat A System.String osztálynak megfelelõ típus. Szövegek között a + és a += szövegösszefûzést végzõ operátorok ismertek. A [] operátor a szöveg adott indexû karakterét adja meg. Az indexelés 0-val kezdõdik. A @ karakter kikü-szöböli a szövegen belüli „érzékeny” karakterek hatását. Ilyen például a backslash (\) karakter. Példa: char c='\u001b'; // c= a 27-es kódú (Esc) karakterrel string s="alma"; string n="alma"+"barack"; s+="fa"; //s= almafa II. A C# nyelv alaptípusai char c1=s[2]; // c1= ’m’ char c2="szia"[1]; // c2=’z’ string f="c:\\programok\\alma.txt"; string file=@"c:\programok\alma.txt"; A String osztály a fenti lehetõségeken kívül egy sor függvénnyel teszi használhatóbbá ezt a típust. Ezen függvények közül a legfontosabbak: Length Csak olvasható tulajdonság, megadja a szöveg karaktereinek a számát: string s="alma"; int i=s.Length; //i=4 CompareTo(string) Két szöveg összehasonlítását végzi. Ha az eredmény 0, akkor azonos a két szöveg: string str1="egyik", str2="másik"; int cmpVal = str1.CompareTo(str2); if (cmpVal = = 0) // az értékek azonosak {...} else if (cmpVal > 0) // str1 nagyobb mint str2 {...} else // str2 nagyobb mint str1 Equals(string) Megadja, hogy a paraméterül kapott szöveg azonos-e az eredeti szöveggel: string str1="egyik", str2="másik"; if (str1.Equals(str2){...} // azonos else{...} // nem azonos IndexOf(string) Több alakja van, megadja, hogy az eredetiben melyik indexnél található a paraméterül kapott szöveg. A visszaadott érték –1 lesz, ha nincs benn a keresett szöveg: int i="almafa".IndexOf("fa"); //4 Insert(int,string) A második paraméterül kapott szöveget, az elsõ paraméterrel megadott indextõl beszúrja az eredeti szövegbe: II. A C# nyelv alaptípusai string s="almafa alatt"; string ujs=s.Insert(4," a "); // alma a fa alatt A szövegtípus további szolgáltatásait, függvényeit a szövegosztály (System.String) online dokumentációjában érdemes megnézni. Meg kell említeni még azt, hogy a szövegosztály függvényei nem módosítják az eredeti szöveget, szövegobjektumot, példaként az elõzõs szöveges változó értéke változatlan marad. Szöveges feldolgozási feladatok során a reguláris kifejezésekkel megadható szövegminták segítségét is igénybe vehetjük. A .NET Framework a Perl5 kompa-tibilis reguláris kifejezéshasználatot támogatja. A Regex osztály szolgáltatja a reguláris kifejezést, míg a Match a találati eredményt. Az osztályokat a System.Text.RegularExpressions névtérben találjuk. Példa: using System; using System.Text.RegularExpressions; class reguláris { public static void Main() { Regex reg_kif = new Regex("fradi"); // a fradi keresése Match találat = reg_kif.Match("A Fradi jó csapat?"); if (találat.Success) { // (hol találtuk meg Console.WriteLine("A találat helye: " + találat.Index); } } } A fenti példa nem ad eredményt, hiszen alapértelmezésben a kis- és nagy-betû különbözik, míg ha a reguláris kifejezést egy kicsit módosítjuk, az alábbiak szerint: Regex reg_kif = new Regex("adi"); akkor a futási eredmény az alábbi lesz: Ha azt szeretnénk elérni, hogy az eredeti szövegünk is változzon, akkor ehhez a System.Text névtér StringBuilder osztályát tudjuk igénybe venni. Példa: using System.Text; ... StringBuilder s1 = new StringBuilder("almafa alatt"); s1.Insert(4," a "); Console.WriteLine(s1); // "alma a fa alatt" int – egész típus(4 byte) Az egész típusú értékek négy bájtot foglalnak – a ma leggyakrabban használt nyelvi környezetben –, így értelmezési tartományuk -231, 231- 1 között van. long hosszú egész (8 byte) short rövid egész (2 byte) sbyte elõjeles (signed) byte float valós (4 byte) double dupla pontosságú valós (8 byte) decimal „pénzügybeli” típus (16 byte), 28 helyiérték Mindkét egész típus elõjeles, ha erre nincs szükségünk, használhatjuk az elõ-jel nélküli változatukat, melyek: uint, ushort, byte, ulong. Valós számok definiálásakor a 10-es kitevõt jelölõe konstans használható. Példa: float a=1.6e-3; // 1.6 * 10-3void – típus nélküli típus Az olyan függvénynek (eljárásnak) a típusa, amelyik nem ad vissza értéket. II. A C# nyelv alaptípusaiPélda: void növel(ref int mit) { mit++; } Az iménti függvény paraméterének jelölése referencia szerinti paraméter-átadást jelent, amirõl a Függvények c. fejezetben részletesen szólunk. bool – logikai típus (1 byte) A logikai típus értéke a true (igaz) vagy false (hamis) értéket veheti fel. Ahogy a nyelv foglalt alapszavainál láthattuk, ezeket az értékeket a true és falsenyelvi kulcsszó adja meg. Általában elmondható, hogy míg a nyelv nem definiál sok alaptípust, addig az egyes implementációk, fõleg azok grafikus felület alatti könyvtárai ezt bõsé-gesen pótolják, és gyakran több idõt kell az 'új típusok' megfejtésének szentelni, mint a függvények tanulmányozásának. II.5. Felsorolás típus A felsorolás típus gyakorlatilag nem más, mint egész konstans(ok), szinoni-mák definiálása. Felsorolás típust névtéren vagy osztályon belül definiálhatunk. Ennek a kulcsszava az enum. A kulcsszó után a felsorolás típus azonosítóját meg kell adni. A System.Enum osztály szinonimáját adja az ezen kulcsszó segítségével definiált típus. Példa: enum szinek {piros,kék,zöld,sárga}; enum betuk {a='a', b='b'}; betuk sajátbetû=betuk.a; // változó kezdõértéke a enum valami { x="alma"}; // hiba Ekkor a 0,1, ... értékek rendelõdnek hozzá a felsorolt nevekhez, és a nevek kiírásakor ezen számokat is látjuk. A kezdõértékadás lehetõségével élve nem kell ezeket feltétlenül elfogadnunk, hanem mi is megadhatjuk az értéküket. Példa: class Szinek { enum újszinek {piros=4, kék=7, zöld=8, sárga=12}; public static void Main() II. A C# nyelv alaptípusai { Console.WriteLine(újszinek.zöld); // kiírja a színt //ciklus a színeken történõ végighaladásra for(újszinek i=újszinek.kék; i<újszinek.sárga; i++) { //kiírja a színeket Console.WriteLine(i); } } } A fenti ciklus eredményeként azon egészek esetén, ahol az egész értékéhez egy „nevet” rendeltünk hozzá, a név kerül kiírásra, egyébként a szám. Az ered-mény a következõ lesz: kék zöld 9 10 11 Mivel ez a típus a System.Enum megfelelõje, ezért rendelkezik annak jellem-zõivel is. Ezek közül a két legjellemzõbb a GetHashCode() és a ToString()függvény. Az elõbbi a belsõ tárolási formát, a megfelelõ egész számot adja meg, míg a ToString(), mint alapértelmezett reprezentáció, a szöveges alakot (kék,zöld, stb) adja meg. Példa: újszinek s=újszinek.piros; Console.WriteLine(s.GetHashCode()); // eredmény: 4 A felsorolás típus alapértelmezésben egész típusú értékeket vesz fel. Ha ez nem megfelelõ, akár byte (vagy tetszõleges egész szinonima) típusú értékeket is felvehet úgy, hogy a típusnév után kettõsponttal elválasztva megadom a típus-nevet. (Nem adhatom meg a valós vagy karakter típust!) Példa: enum színek:byte {piros,kék,zöld,sárga}; ... enum hibás:float {rossz1, rossz2}; // ez fordítási hiba Elõfordulhat, hogy olyan felsorolásadatokra van szükségem, melyek nem egy egész konstanshoz, hanem egy bithez kötõdnek, hiszen ekkor a logikai II. A C# nyelv alaptípusaiés/vagy mûveletekkel a felsorolásadatok kombinációját határozhatjuk meg. Ebben az esetben a [Flags]attribútumot kell az enum szócska elé szúrni. Példa: [Flags] enum alma {piros=1,jonatán=2,zöld=4,golden=8}; ... alma a=alma.piros | alma.jonatán; Console.WriteLine(a); // piros, jonatán a=(alma) System.Enum.Parse(typeof(alma),"zöld,golden"); // a felsorolás típus egyszerû értékadása helyett // a könyvtári hívás lehetõségét is használhatjuk // Console.WriteLine(a.GetHashCode()); ... // eredmény 12 lesz Bithez kötött értékek esetén kötelezõ minden egyes konstans névhez meg-adni a neki megfelelõ bites ábrázolást! Az alaptípusokat a .NET keretrendszer biztosítja, így ennek a fejlesztési környezetnek egy másik nyelvében pontosan ezek a típusok állnak rendelke-zésre. Az természetesen elõfordulhat, hogy nem ezekkel a nevekkel kell rájuk hivatkozni, de a nyelvi fordító biztosan ezen értelmezés szerinti kódot (köztes kód) fordítja le a keretrendszer, mint futtató környezet számára. Az alaptípusok zárásaként meg kell jegyezni, hogy a mutató típus is értelme-zett, ahogy a C++ világában, de ennek a használata csak olyan C# programrész-ben megengedett, amely nem biztonságos környezetben helyezkedik el (unsafe context). Errõl röviden a könyv XIV. fejezetében olvashat. 